name: _test (Reusable workflow)

on:
  workflow_call:
    inputs:
      test-project:
        description: Path to the test project to run tests against (cannot be null or empty string)
        type: string
        required: true

      test-subject:
        description: The name of the project being tested, without the .csproj suffix (can be null or empty string, in which case it is inferred from the test project)
        type: string
        required: false

      runner-os:
        description: Runner OS
        type: string
        default: ubuntu-latest

      dotnet-version:
        description: Version of .NET SDK to use (cannot be null or empty string, default 10.0.x)
        type: string
        default: 10.0.x

      configuration:
        description: The type of build to produce, e.g. Release vs Debug (cannot be null or empty string, default Release)
        type: string
        default: Release

      preprocessor-symbols:
        description: Define constants to pass to the compiler
        type: string
        default: ""

      min-coverage-pct:
        description: Minimum acceptable code coverage percentage (cannot be 0, null or empty, default 80)
        type: number
        default: 80 # percent

      minver-tag-prefix:
        description: MinVer tag prefix to use for version calculation. Cannot be null or empty!
        type: string
        default: v

      minver-prerelease-id:
        description: MinVer default pre-release identifiers to use for version calculation. Cannot be null or empty!
        type: string
        default: preview

    secrets:
      CODECOV_TOKEN:
        description: Codecov API token for uploading coverage reports
        required: true

permissions:
  contents: read # to checkout the code
  checks: write # to create test result checks
  pull-requests: write # to comment test results on PRs

env:
  # this must be the same across all jobs and steps below.
  # We must know where to find the artifacts and where to download/upload to/from across all jobs and steps here.
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  VERBOSE: ${{ vars.VERBOSE }}

jobs:
  # Execute unit tests with code coverage and enforce minimum coverage threshold
  test:
    name: Test on ${{ inputs.runner-os }}
    runs-on: ${{ inputs.runner-os }}
    steps:
      # Clone the repository with full Git history
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          filter: tree:0

      # Clone only the scripts from vm2.DevOps, so that we can run the composite
      # action .github/actions/scripts/action.yaml for both local and external calls
      - name: Checkout vm2.DevOps repository scripts
        if: github.repository != 'vmelamed/vm2.DevOps'
        uses: actions/checkout@v6
        with:
          repository: vmelamed/vm2.DevOps
          path: vm2-devops
          sparse-checkout: |+
            scripts/bash/lib
            .github/actions/scripts
      - name: Add vm2.DevOps to PATH for work inside vm2.DevOps
        if: github.repository == 'vmelamed/vm2.DevOps'
        uses: ./.github/actions/scripts
      - name: Add vm2.DevOps to PATH for work outside vm2.DevOps
        if: github.repository != 'vmelamed/vm2.DevOps'
        uses: ./vm2-devops/.github/actions/scripts

      # Generate a weekly cache key to automatically rotate NuGet cache
      - name: Get cache timestamp (weekly rotation)
        id: cache-timestamp
        shell: bash
        run: |
          # Generate cache key based on calendar week
          CACHE_WEEK=$(date +%Y-W%V)
          echo "week=$CACHE_WEEK" >> $GITHUB_OUTPUT
          echo "Cache rotation key: $CACHE_WEEK"

      # Install .NET SDK with built-in NuGet package caching
      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.dotnet-version }}
          dotnet-quality: 'ga'
          cache: true
          cache-dependency-path: |
            **/packages.lock.json
            **/*.csproj

      # Authenticate to GitHub Packages for vm2.TestUtilities restore
      - name: Configure GitHub Packages source
        shell: bash
        run: |
          dotnet nuget update source github.vm2 \
              --username "$GITHUB_ACTOR" \
              --password "${{ secrets.GITHUB_TOKEN }}" \
              --store-password-in-clear-text \
              --configfile NuGet.config

      # Additional explicit cache layer with time-based rotation for NuGet packages
      - name: Cache NuGet packages (weekly rotation)
        uses: actions/cache@v5
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ steps.cache-timestamp.outputs.week }}-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            nuget-${{ runner.os }}-${{ steps.cache-timestamp.outputs.week }}-
            nuget-${{ runner.os }}-

      # Retrieve compiled binaries from the build job to avoid recompilation
      - name: Restore build artifacts from cache
        uses: actions/cache/restore@v5
        with:
          key: build-artifacts-${{ runner.os }}-${{ github.sha }}-${{ inputs.configuration }}-${{ github.run_id }}
          fail-on-cache-miss: true
          path: |
            **/bin/${{ inputs.configuration }}
            **/obj

      - name: Verify the artifacts were restored and run the tests
        id: run-tests
        shell: bash
        run: |
          ARTIFACT_PATH=$(find . -type d -path "*/bin/${{ inputs.configuration }}" | head -n 1)
          if [ -z "$ARTIFACT_PATH" ]; then
              warning "No build artifacts found in cache."
              exit 1
          else
              echo "Build artifacts found at: $ARTIFACT_PATH"
              # uncomment the next 2 lines if you want to debug the contents of the artifact path
              # ls -la "$ARTIFACT_PATH"/**/*.*
              # ls -la ./test/**/bin/${{ inputs.configuration }}/*.*
          fi

          run-tests.sh ${{ inputs.test-project }} \
              --define "${{ inputs.preprocessor-symbols }}" \
              --configuration "${{ inputs.configuration }}" \
              --min-coverage-pct "${{ inputs.min-coverage-pct }}" \
              --minver-tag-prefix "${{ inputs.minver-tag-prefix }}" \
              --minver-prerelease-id "${{ inputs.minver-prerelease-id }}"

      - name: Generate coverage report
        uses: danielpalme/ReportGenerator-GitHub-Action@5.5.1
        env:
          REPORTGENERATOR_LICENSE: ${{ secrets.REPORTGENERATOR_LICENSE }}
        with:
          reports: ${{ steps.run-tests.outputs.coverage-source-path }}
          targetdir: ${{ steps.run-tests.outputs.coverage-reports-dir }}
          reporttypes: Html_Dark;Badges;MarkdownSummaryGithub
          # MTP v2 already handles most exclusions via Directory.Build.props
          # Only exclude interfaces and compiler-generated items here
          classfilters: -*.I[A-Z]*
          filefilters: -*.MoveNext;-*.d__*;-*.<>c*
          # Don't exclude test projects here - MTP v2 already handles it
          customSettings: minimumCoverageThresholds:lineCoverage=${{ inputs.min-coverage-pct }};minimumCoverageThresholds:branchCoverage=${{ inputs.min-coverage-pct }};minimumCoverageThresholds:methodCoverage=${{ inputs.min-coverage-pct }};minimumCoverageThresholds:fullMethodCoverage=${{ inputs.min-coverage-pct }}

      # Upload test results and coverage reports as workflow artifacts
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v6
        id: upload-coverage
        with:
          name: coverage-${{ steps.run-tests.outputs.proj-name }}-${{ inputs.runner-os }}
          path: ${{ steps.run-tests.outputs.coverage-reports-dir }}
          if-no-files-found: error
          overwrite: true

      - name: Add comment to PR # Only applicable if 'MarkdownSummaryGithub' or one of the other Markdown report types is generated
        if: github.event_name == 'pull_request'
        run: gh pr comment $PR_NUMBER --edit-last --create-if-none --body-file ${{ steps.run-tests.outputs.coverage-reports-dir }}/SummaryGithub.md # Adjust path and filename if necessary
        env:
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            PR_NUMBER: ${{ github.event.number }}

      # # Upload coverage to Codecov for online viewing and PR integration
      # - name: Upload coverage to Codecov
      #   uses: codecov/codecov-action@v5
      #   env:
      #     CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
      #   with:
      #     flags: ${{ steps.run-tests.outputs.proj-name }}-${{ inputs.runner-os }}
      #     slug: ${{ github.repository }}
      #     files: ${{ steps.run-tests.outputs.coverage_source_path }}
      #     fail_ci_if_error: false
#
      # # Create test result check and PR comment
      # - name: Publish test results
      #   uses: EnricoMi/publish-unit-test-result-action@v2
      #   with:
      #     check_name: Test Results (${{ steps.run-tests.outputs.proj-name }} on ${{ inputs.runner-os }})
      #     files: |
      #       ${{ steps.run-tests.outputs.artifacts-dir }}/**/*.trx
      #       ${{ steps.run-tests.outputs.artifacts-dir }}/**/*.xml
      #     comment_mode: always
      #     compare_to_earlier_commit: true
      #     report_individual_runs: true
      #     deduplicate_classes_by_file_name: false

      # Add coverage check status to summary
      #  - name: Verify coverage threshold
      #    if: always()
      #    shell: bash
      #    run: |
      #      LINE_PCT="${{ steps.run-tests.outputs.line_pct }}"
      #      MIN_PCT="${{ inputs.min-coverage-pct }}"

      #      {
      #          echo "### ðŸ“Š Code Coverage"
      #          echo ""
      #          echo "**Line Coverage:** ${LINE_PCT}%"
      #          echo "**Minimum Required:** ${MIN_PCT}%"
      #          echo ""
      #          if (( $(echo "$LINE_PCT < $MIN_PCT" | bc -l) )); then
      #              echo "âŒ **FAILED:** Coverage ${LINE_PCT}% is below threshold ${MIN_PCT}%"
      #              echo ""
      #              echo "::error::Code coverage ${LINE_PCT}% is below the minimum required threshold of ${MIN_PCT}%"
      #          else
      #              echo "âœ… **PASSED:** Coverage meets threshold"
      #          fi
      #      } >> $GITHUB_STEP_SUMMARY

      # Add coverage report link to job summary
      - name: Add coverage report link to summary
        if: always()
        shell: bash
        run: |
          {
              echo "### ðŸ“Š Coverage Report - ${{ steps.run-tests.outputs.proj-name }}"
              echo ""
              echo "ðŸŒ View on [Codecov](https://app.codecov.io/gh/${{ github.repository }}/commit/${{ github.sha }})"
              echo ""
              echo "ðŸ“¥ Or download the [coverage-${{ steps.run-tests.outputs.proj-name }}-${{ inputs.runner-os }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) artifact to view the HTML report locally."
              echo ""
              echo "Open \`coverage/html/index.html\` from the downloaded artifact in your browser."
          } >> $GITHUB_STEP_SUMMARY
