name: _test (Reusable workflow)

on:
  workflow_call:
    inputs:
      test-projects:
        description: JSON array string of test project paths to run tests against (cannot be null or empty string)
        type: string
        required: true

      test-subject:
        description: The name of the project being tested, without the .csproj suffix (can be null or empty string, in which case it is inferred from the test project)
        type: string
        required: false

      runner-os:
        description: Runner OS
        type: string
        default: ubuntu-latest

      dotnet-version:
        description: Version of .NET SDK to use (cannot be null or empty string, default 10.0.x)
        type: string
        default: 10.0.x

      configuration:
        description: The type of build to produce, e.g. Release vs Debug (cannot be null or empty string, default Release)
        type: string
        default: Release

      preprocessor-symbols:
        description: Define constants to pass to the compiler
        type: string
        default: ""

      min-coverage-pct:
        description: Minimum acceptable code coverage percentage (cannot be 0, null or empty, default 80)
        type: number
        default: 80 # percent

      minver-tag-prefix:
        description: MinVer tag prefix to use for version calculation. Cannot be null or empty!
        type: string
        default: v

      minver-prerelease-id:
        description: MinVer default pre-release identifiers to use for version calculation. Cannot be null or empty!
        type: string
        default: preview.0

    secrets:
      CODECOV_TOKEN:
        description: Codecov API token for uploading coverage reports
        required: true
      REPORTGENERATOR_LICENSE:
        description: ReportGenerator license key for enhanced coverage reports
        required: false

permissions:
  contents: read # to checkout the code
  checks: write # to create test result checks
  pull-requests: write # to comment test results on PRs

env:
  # this must be the same across all jobs and steps below.
  # We must know where to find the artifacts and where to download/upload to/from across all jobs and steps here.
  DOTNET_NOLOGO: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  VERBOSE: ${{ vars.VERBOSE }}

jobs:
  # Execute unit tests with code coverage and enforce minimum coverage threshold
  test:
    name: Test on ${{ inputs.runner-os }}
    runs-on: ${{ inputs.runner-os }}
    steps:
      # Clone the repository with full Git history
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          filter: tree:0

      # Clone only the scripts from vm2.DevOps, so that we can run the composite
      # action .github/actions/scripts/action.yaml for both local and external calls
      - name: Checkout vm2.DevOps repository scripts
        if: github.repository != 'vmelamed/vm2.DevOps'
        uses: actions/checkout@v6
        with:
          repository: vmelamed/vm2.DevOps
          path: vm2-devops
          persist-credentials: false
          sparse-checkout: |+
            scripts/bash/lib
            .github/actions/scripts
      - name: Add vm2.DevOps to PATH for work inside vm2.DevOps
        if: github.repository == 'vmelamed/vm2.DevOps'
        uses: ./.github/actions/scripts
      - name: Add vm2.DevOps to PATH for work outside vm2.DevOps
        if: github.repository != 'vmelamed/vm2.DevOps'
        uses: ./vm2-devops/.github/actions/scripts

      # Generate a weekly cache key to automatically rotate NuGet cache
      - name: Get cache timestamp (weekly rotation)
        id: cache-timestamp
        shell: bash
        run: |
          # Generate cache key based on calendar week
          CACHE_WEEK=$(date +%Y-W%V)
          echo "week=$CACHE_WEEK" >> $GITHUB_OUTPUT
          echo "Cache rotation key: $CACHE_WEEK"

      # Install .NET SDK with built-in NuGet package caching
      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.dotnet-version }}
          dotnet-quality: 'ga'
          cache: true
          cache-dependency-path: |
            **/packages.lock.json
            **/*.csproj

      # Authenticate to GitHub Packages for vm2.TestUtilities restore
      - name: Configure GitHub Packages source
        shell: bash
        run: |
          dotnet nuget update source github.vm2 \
              --username "$GITHUB_ACTOR" \
              --password "${{ secrets.GITHUB_TOKEN }}" \
              --store-password-in-clear-text \
              --configfile NuGet.config

      # Additional explicit cache layer with time-based rotation for NuGet packages
      - name: Cache NuGet packages (weekly rotation)
        uses: actions/cache@v5
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ steps.cache-timestamp.outputs.week }}-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: |
            nuget-${{ runner.os }}-${{ steps.cache-timestamp.outputs.week }}-
            nuget-${{ runner.os }}-

      # Retrieve compiled binaries from the build job to avoid recompilation
      - name: Restore build artifacts from cache
        uses: actions/cache/restore@v5
        with:
          key: build-artifacts-${{ runner.os }}-${{ github.sha }}-${{ inputs.configuration }}-${{ github.run_id }}
          fail-on-cache-miss: true
          path: |
            **/bin/${{ inputs.configuration }}
            **/obj

      - name: Verify the artifacts were restored and run the tests
        id: run-tests
        shell: bash
        env:
          REPORTGENERATOR_LICENSE: ${{ secrets.REPORTGENERATOR_LICENSE }}
          TEST_VAR: test-value
        run: |
          ARTIFACT_PATH=$(find . -type d -path "*/bin/${{ inputs.configuration }}" | head -n 1)
          if [ -z "$ARTIFACT_PATH" ]; then
              warning "No build artifacts found in cache."
              exit 1
          else
              echo "Build artifacts found at: $ARTIFACT_PATH"
              # uncomment the next 2 lines if you want to debug the contents of the artifact path
              # ls -la "$ARTIFACT_PATH"/**/*.*
              # ls -la ./test/**/bin/${{ inputs.configuration }}/*.*
          fi

          # Parse test projects JSON array and run each test project
          tests_artifacts_dir="./TestResults"
          TEST_PROJECTS='${{ inputs.test-projects }}'
          echo "$TEST_PROJECTS" | jq -r '.[]' | while read -r test_project; do
            echo "Running tests for: $test_project"
            run-tests.sh "$test_project" \
                --define "${{ inputs.preprocessor-symbols }}" \
                --configuration "${{ inputs.configuration }}" \
                --min-coverage-pct "${{ inputs.min-coverage-pct }}" \
                --minver-tag-prefix "${{ inputs.minver-tag-prefix }}" \
                --minver-prerelease-id "${{ inputs.minver-prerelease-id }}" \
                --artifacts "$tests_artifacts_dir"
                # This is the root artifacts directory. The script will create a subdirectory for each test project,
                # e.g. ./TestResults/<test-project-name>/*
          done

          # Set outputs for merged coverage
          repo_name=$(basename "$(git rev-parse --show-toplevel)")
          echo "proj-name=${repo_name}" >> $GITHUB_OUTPUT
          echo "artifacts-dir=$tests_artifacts_dir" >> $GITHUB_OUTPUT
          echo "coverage-source-path=**/$tests_artifacts_dir/**/coverage.cobertura.xml" >> $GITHUB_OUTPUT
          echo "coverage-reports-dir=$tests_artifacts_dir/reports" >> $GITHUB_OUTPUT

      - name: Generate coverage report
        uses: danielpalme/ReportGenerator-GitHub-Action@5.5.1
        env:
          REPORTGENERATOR_LICENSE: ${{ secrets.REPORTGENERATOR_LICENSE }}
        with:
          reports: ${{ steps.run-tests.outputs.coverage-source-path }}
          targetdir: ${{ steps.run-tests.outputs.coverage-reports-dir }}
          reporttypes: MarkdownSummaryGithub
          customSettings: >
            minimumCoverageThresholds:lineCoverage=${{ inputs.min-coverage-pct }};
            minimumCoverageThresholds:branchCoverage=${{ inputs.min-coverage-pct }};
            minimumCoverageThresholds:methodCoverage=${{ inputs.min-coverage-pct }};
            minimumCoverageThresholds:fullMethodCoverage=${{ inputs.min-coverage-pct }}

      - name: Copy coverage reports to GitHub Actions step output directory
        shell: bash
        run: |
          cat ${{ steps.run-tests.outputs.coverage-reports-dir }}/*.md >> $GITHUB_STEP_SUMMARY

      # Upload test results and coverage reports as workflow artifacts
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v6
        id: upload-coverage
        with:
          name: coverage-${{ steps.run-tests.outputs.proj-name }}-${{ inputs.runner-os }}
          path: ${{ steps.run-tests.outputs.coverage-reports-dir }}
          if-no-files-found: error
          overwrite: true

      - name: Add comment to PR # Only applicable if 'MarkdownSummaryGithub' or one of the other Markdown report types is generated
        if: github.event_name == 'pull_request'
        run: gh pr comment $PR_NUMBER --edit-last --create-if-none --body-file ${{ steps.run-tests.outputs.coverage-reports-dir }}/SummaryGithub.md # Adjust path and filename if necessary
        env:
            GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            PR_NUMBER: ${{ github.event.number }}

      # Upload coverage to Codecov for historical tracking and PR integration
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ${{ steps.run-tests.outputs.coverage-source-path }}
          flags: ${{ steps.run-tests.outputs.proj-name }}-${{ inputs.runner-os }}
          name: ${{ steps.run-tests.outputs.proj-name }}-${{ inputs.runner-os }}
          fail_ci_if_error: false
          verbose: true

      - name: Coverage report on CodeCov
        shell: bash
        run: |
          echo "[Coverage report](https://app.codecov.io/gh/${{ github.repository }}/tree/${{ github.ref_name }})" >> $GITHUB_STEP_SUMMARY
